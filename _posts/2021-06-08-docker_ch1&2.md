--- 
title: "[Docker] 도커 엔진"
excerpt: 시작하세요! 도커/쿠버네티스 Ch 2.

categories:
    - Docker
tags:
    - Docker
use_math: true
toc: true
toc_sticky: true
---

## 2.1.1 도커 이미지
- 컨테이너 생싱 시 필요
- 읽기 전용
- [저장소이름]/[이미지 이름]:[태그]
    - 저장소 이름: 이미지가 저장된 장소. default는 도커 허브의 공식 이미지
    - 이미지 이름: 이미지의 역할
    - 태그: 버전관리, revision

## 2.1.2 도커 컨테이너
- 이미지의 목적에 마즌 파일이 들어있는 파일 시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성됨.
- 이미지 종류에 따라 알맞은 설정과 파일 갖고있음
- 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 컨테이너 계층에 저장 -> 원래 이미지는 영향 X
- 컨테이너와 호스트 상호 독립

## 2.4.2 컨테이너를 외부에 노출
- ifconfig의 eth0의 IP와 포트를 host IP에 바인딩 해야 외부에서 접근 가능
docker run -i -t --name mywebserver -p 80:80
    - 80 (앞) : host port
    - 80 (뒤) : container port
    - host의 특정 port와 container의 port binding

## 2.2.5 컨테이너 애플리케이션 구축
- 한 컨테이너에 하나의 프로세스만 실행하는 것이 도커의 철학
- -d 옵션으로 run 하면 detach 모드로 run 가능
- -e는 docker 내부에 환경변수 생성 가능
- -link는 ip를 알 필요 없이 hostname으로 접근 하도록 설정
    - deprecated 됐고 도커 bridge로 동일한 기능 사용 가능

## 2.2.6 도커 볼륨
- 도커 이미지는 읽기 전용이므로 컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보 보존
- but 컨테이너를 삭제하면 컨테이너 계층에 저장되어 있는 정보 (ex database)도 삭제됨
-> 볼륨 사용으로 해결!

1. 호스트와 볼륨 사용
    - -v [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리]
    - 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트

2. 볼륨 컨테이너
    - -volumnes-from 옵션을 통해 -v 또는 --volumn 옵션을 적용한 컨테이너의 볼륨 디렉터리 공유 가능

3. 도커 볼륨
    - docker volumn 생성 후 활용
    - 로컬 호스트에 저장됨
    - 도커 엔진에 의해 생성되고 삭제됨
    - -v [볼륨의 이름]:[컨테이너의 공유 디렉터리]

- 볼륨은 디렉터리 하나에 상응하는 단위
- 도커 엔진에서 관리
- 어디에 저장되는지 알 필요 없지만 docker inspect하면 알 수 있음
- 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터가 동작하도록 설계하는 것을 스테이트리스(stateless) 하다고 말함 -> 바람직
- 컨테이너가 데이터를 저장하고 있어서 상태가 있는 경우를 stateful 하다고 말함 -> 지양

## 2.2.7 도커 네트워크
- 도커는 컨테이너 내부 IP를 순차적으로 할당 -> veth
- 컨테이너 재시작 할 때마다 변경됨
- 내부망(호스트)에서만 쓰므로 외부와 연결될 필요 X
- 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성 (veth로 시작)
- veth 인터페이스는 컨테이너가 생성될 때 토커 엔진이 자동 생성
- veth는 각 컨테이너의 eth0와 연결됨
- docker0 브리지는 각 veth 인터페이스와 바인딩 됨 -> host의 eth0 인터페이스와 연결시켜줌

1. 브리지 네트워크
- 컨테이너 생성할 때 자동으로 연결되는 docker0 네트워크 활용
- 172.17.0.X IP 대역 순차 할당
- 사용자 정의 브리지는 새로 생성해 각 컨테이너에 연결
- 브리지 타입의 네트워크를 생성하면 IP 대역을 차례대로 할당

2. 호스트 네트워크
- 호스트의 네트워크 환경 그대로 사용
- 호스트 머신에서 설정한 호스트 이름 물려받음
- 컨테이너 내부의 애플리케이션을 별도의 포트 포워딩 없이 바로 서비스 가능 -> 실제 호스트에서 애플리케이션을 외부에 노출하는 것과 같음

3. 논 네트워크
- 아무런 네트워크를 쓰지 않는 것
- 외부와 연결이 단절됨

4. 컨테이너 네트워크
- 다른 컨테이너의 네트워크 네임스페이스 환경 공유
    - IP, 네트워크 인터페이스의 맥 (MAC) 주소 등
- 내부 IP 새로할당 X
- 호스트에 veth로 시작하는 가상 네트워크 인터페이스 생성 X

5. 브리지 네트워크의 --net-alias
- 특정 호스트 이름으로 컨테이너 여러개에 접근 가능
- 도커 엔진에 내장된 DNS가 호스트 일므이 같은 컨테이너로 변환. round robin 방식 사용
- DNS는 호스트 이름으로 유동적인 컨테이너 찾을 때 사용됨

6. MacVLAN 네트워크
- 컨테이너는 물리 네트워크상에서 가상의 맥(MAC) 주소를 가지며 해당 네트워크에 연결된 다른 장치와의 통신이 가능해짐
    - 기본적으로 할당되는 IP대역인 172.17.XX 아니고 네트워크 장비의 IP할당받기 때문
- 호스트와 통신 불가능
- 적어도 1개의 네트워크 장비와 서버 필요

## 2.2.8 컨테이너 로깅
- 기본적으로 JSON 형태로 log를 저장하지만 로깅 드라이버를 사용해 컨테이너 로그를 수집할 수 도 있음

1. syslog 로그
- 유닉스 계열 운영체제에서 로그를 수집하는 오래된 표준 중 하나
- 커널, 보안, 시스템 등과 관련된 로그, 애플리케이션 로그 등 수집
- 유닉스 계열 체제에서는 syslog를 사용하는 인터페이스가 동일 -> 체계적인 로그 수집 가능
- 원격 서버에 syslog를 설치해서 로그 정보를 원격 서버로 보내기 가능

2. fluentd 로깅
- 로그 수집 저장
- JSON 사용
- AWS S3, HDFS, MongoDB 등 다양한 저장소에 저장 가능

## 2.2.9 컨테이너 자원 할당
- 자원할당을 안하면 호스트의 자원을 전부 점유해 다른 컨테이너들 뿐 아니라 호스트 자체의 동작이 멈출 수 도 있음

1. 컨테이너 메모리 제한
- 할당된 메모리를 초과하면 자동으로 종료됨
- 기본적으로 swap 메모리는 메모리의 2배로 설정됨

2. 컨테이너 cpu 제한
    1. --cpu-shares
        - 컨테이너에 가중치 할당
        - 존재하는 cpu를 어느 비중만큼 나눠 쓸 것인지

    2. --cpuset-cpu
        -호스트에 cpu가 여러개 있을 때 컨테이너가 특정 cpu만 사용하도록 설정
    
    3. --cpu-period, --cpu-quota
        - 컨테이너의 CFS (Completely Fair Scheduler) 주기는 기본적으로 100ms로 설정되지만 주기 변경 가능
        - --cpu-period의 기본값은 100000이며 100ms를 뜻함
        - --cpu-quotasms --cpu-period에 설정된 시간 중 cpu 스케줄링에 얼마나 할당할 것인지 설정
    4. --cpus
        - --cpu-period, --cpu-quota와 같은데 더 직관적
        - cpu 개수 직접 지정
        - 병렬처리를 위해 cpu를 마니 소모하는 워크로드를 수행해야 한다면 --cpuset-cpu 옵션을 사용하는게 좋음. 특정 컨테이너가 특정 cpu에서만 동작하는 cpu 친화성 보장. cpu 캐시 미스, 컨텍스 스위칭 최소화

3. Block I/O 제한
    - 기본적으로 컨테이너 내부에서 파일을 읽고 쓰는 대역폭에 제한 X
    - DIRECT I/O의 경우에서는 입출력만 제한됨. Buffered I/O는 제한 X
    - 상대적인 값으로 입력

4. 스토리지 드라이버와 컨테이너 저장 공간 제한
    - 컨테이너 내부의 저장 공간을 제한하는 기능을 보편적으로 제공 X
    - but 도커의 스토리지 드라이버나 파일 시스템 등이 특정 조건을 만족하는 경우에만 제한적으로 사용 가능
    - 나중에 설명 더 해줌

## 2.3 도커 이미지
    - 도커 허브라는 중앙 이미지 저장소에서 이미지 내려받음

## 2.3.1 도커 이미지 생성
    - 컨테이너에서 변경사항을 만든 후 docker commit

## 2.3.2 이미지 구조 이해
    - 이미지를 커밋할 때 컨테이너에서 변경된 사항만 새로운 레이어로 저장
    - docker rmi하면 삭제됨
        - 실행중인데 강제로 삭제하면 이미지 레이어 파일을 실제로 삭제하지 않고 이미지 이름만 삭제
            - docker rmi -f
            - 이름이 <none>으로 변경되고 dangling 이미지가 됨. docker image prune을 통해 한번에 삭제 가능
        - 이미지를 사용중인 컨테이너 stop 후 이미지를 삭제하면 정상적으로 삭제 가능
        - 해당 이미지를 사용한 commit이 있다면 이미지 파일이 삭제가 되는 것이 아니라 레이어에 부여된 이름만 삭제됨

## 2.3.3 이미지 추출
- docker save를 하면 컨테이너의 커맨드, 이미지 이름과, 태그 등 이미지의 모든 메타데이터를 퐇마해 하나의 파일로 추출 가능
- 단일 파일로 저장하는 것은 효율적인 방법이 아님

## 2.3.4 이미지 배포
- 파일로 배포시 용량이 너무 크면 힘듦 & 도커의 이미지 구조인 레이어 사용 x -> 비효율적

1. 도커 저장소 사용
    - private은 유료
2. Docker Private Registry 사용
    - 직접 이미지 저장소 만들기